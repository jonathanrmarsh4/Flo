{
  "purpose": "Design and implement a HealthKit-based sleep processing and scoring engine for Flo that converts raw HKCategoryTypeIdentifier.sleepAnalysis samples (and optional vitals) into nightly sleep metrics and a personalized 0–100 Sleep Score.",
  "data_sources": {
    "healthkit": {
      "sleep_category_type": "HKCategoryTypeIdentifier.sleepAnalysis",
      "sleep_values": [
        "HKCategoryValueSleepAnalysis.inBed",
        "HKCategoryValueSleepAnalysis.awake",
        "HKCategoryValueSleepAnalysis.asleepCore",
        "HKCategoryValueSleepAnalysis.asleepDeep",
        "HKCategoryValueSleepAnalysis.asleepREM",
        "HKCategoryValueSleepAnalysis.asleepUnspecified",
        "HKCategoryValueSleepAnalysis.asleep (deprecated legacy)"
      ],
      "recommended_metadata": [
        "HKMetadataKeyTimeZone",
        "HKMetadataKeyDeviceName",
        "HKMetadataKeyExternalUUID",
        "HKMetadataKeySyncIdentifier",
        "HKMetadataKeySyncVersion"
      ],
      "optional_vitals": [
        "HKQuantityTypeIdentifier.restingHeartRate",
        "HKQuantityTypeIdentifier.heartRateVariabilitySDNN",
        "HKQuantityTypeIdentifier.respiratoryRate",
        "HKQuantityTypeIdentifier.wristTemperature",
        "HKQuantityTypeIdentifier.oxygenSaturation"
      ]
    },
    "user_profile": {
      "fields": [
        "user_id",
        "date_of_birth",
        "biological_sex",
        "primary_time_zone",
        "preferred_bedtime_window (optional)",
        "preferred_wake_window (optional)"
      ]
    }
  },
  "normalisation_pipeline": {
    "sleep_day_definition": {
      "description": "Group sleep into nights using a custom 24-hour window.",
      "rules": [
        "Determine local timezone from HKMetadataKeyTimeZone if present; otherwise fall back to user.primary_time_zone.",
        "Define each 'sleep day' as the local calendar day of the final wake time.",
        "For querying, use a rolling 24-hour window of 15:00 previous calendar day to 15:00 current calendar day in the local timezone."
      ]
    },
    "query_strategy": {
      "description": "Fetch raw sleep samples from HealthKit.",
      "steps": [
        "For a given sleep day D, compute query_start = D-1 at 15:00 local, query_end = D at 15:00 local.",
        "Create an HKSampleQuery (or async equivalent) for HKCategoryTypeIdentifier.sleepAnalysis with predicate (startDate >= query_start AND endDate <= query_end).",
        "Sort results by startDate ascending, then endDate ascending."
      ]
    },
    "source_prioritisation": {
      "description": "Resolve multi-device / multi-app overlaps into a single authoritative sleep timeline per night.",
      "rules": [
        "Group samples by overlapping time ranges.",
        "Within each overlapping group and value type, select a primary sample according to priority:",
        "1) Apple first-party sleep sources (bundle ID starting with 'com.apple.health' or official Sleep app identifiers).",
        "2) User-configured primary sleep device (e.g. Apple Watch vs other tracker).",
        "3) Higher temporal resolution (shorter average segment duration) wins if still tied.",
        "Drop lower-priority duplicates for the same interval and value.",
        "Ensure the final timeline is non-overlapping for stage values (awake/core/deep/REM/unspecified/asleep). 'inBed' may overlap these as a separate track."
      ]
    },
    "timeline_construction": {
      "description": "Build a structured representation of the night's sleep.",
      "outputs": [
        "in_bed_segments: [{ start, end }]",
        "stage_segments: [{ start, end, stage_value }], where stage_value ∈ { awake, asleepCore, asleepDeep, asleepREM, asleepUnspecified, asleep_legacy }"
      ],
      "steps": [
        "Filter resolved samples into 'inBed' vs stage values.",
        "Sort each list by start time.",
        "Merge adjacent segments of the same type if separated by <= 60 seconds to reduce fragmentation noise.",
        "Store results as the canonical nightly sleep timeline."
      ]
    }
  },
  "nightly_metrics": {
    "inputs": [
      "in_bed_segments",
      "stage_segments",
      "local_timezone"
    ],
    "derived_timestamps": [
      "night_start = min(start of in_bed_segments, start of first stage_segment) if any, else null",
      "final_wake = max(end of in_bed_segments, end of last stage_segment) if any, else null",
      "sleep_onset = start of first stage_segment whose value is any asleep* (core/deep/REM/unspecified/asleep legacy)"
    ],
    "metrics": {
      "time_in_bed_min": "Total duration in minutes of the union of all in_bed_segments.",
      "total_sleep_min": "Total duration in minutes of the union of all stage_segments with values in {asleepCore, asleepDeep, asleepREM, asleepUnspecified, asleep legacy}.",
      "sleep_efficiency_pct": "100 * total_sleep_min / time_in_bed_min, clamped to [0, 100].",
      "sleep_latency_min": "If both in_bed_segments and asleep segments exist: minutes from first in_bed start to first asleep* segment; otherwise null.",
      "waso_min": "Sum of 'awake' stage_segments durations that occur between sleep_onset and final_wake.",
      "num_awakenings": "Count of 'awake' stage_segments >= MIN_AWAKE_DURATION_MIN (configurable, default 2 or 5 minutes) between sleep_onset and final_wake.",
      "core_sleep_min": "Sum of durations of stage_segments with value asleepCore.",
      "deep_sleep_min": "Sum of durations of stage_segments with value asleepDeep.",
      "rem_sleep_min": "Sum of durations of stage_segments with value asleepREM.",
      "unspecified_sleep_min": "Sum of durations of stage_segments with value asleepUnspecified or legacy asleep.",
      "awake_in_bed_min": "Total duration of 'awake' stage_segments that overlap any in_bed_segment.",
      "mid_sleep_time_local": "Local clock time halfway between sleep_onset and final_wake (e.g. as minutes since midnight).",
      "fragmentation_index": "num_awakenings / max(total_sleep_min / 60, 0.1)",
      "stage_percentages": {
        "deep_pct": "100 * deep_sleep_min / total_sleep_min (if total_sleep_min > 0)",
        "rem_pct": "100 * rem_sleep_min / total_sleep_min",
        "core_pct": "100 * core_sleep_min / total_sleep_min"
      }
    }
  },
  "history_and_baselines": {
    "window_days": 28,
    "aggregations": [
      "For each metric: compute rolling median and standard deviation (ignoring nights with missing data).",
      "Example metrics to baseline: total_sleep_min, deep_pct, rem_pct, sleep_efficiency_pct, mid_sleep_time_local, resting_heart_rate, hrv, respiratory_rate, wrist_temperature."
    ],
    "z_score_logic": "For each nightly metric m with history: z_m = (value_m - baseline_median_m) / max(baseline_std_m, epsilon). Clamp z_m to [-2.0, +2.0]."
  },
  "subscores": {
    "duration_score": {
      "description": "How close nightly sleep duration is to guideline and personal baseline.",
      "inputs": [
        "total_sleep_min",
        "baseline_total_sleep_min",
        "z_total_sleep"
      ],
      "guideline_range_min_min": 420,
      "guideline_range_max_min": 540,
      "algorithm": [
        "duration_norm = piecewise score: 100 if within [420, 540] minutes, linearly decreasing to 0 at 270 minutes (4.5h) and 600 minutes (10h).",
        "duration_rel = clamp(50 + 25 * (-z_total_sleep), 0, 100). Negative z (less sleep than baseline) lowers score; positive z raises score.",
        "duration_score = 0.6 * duration_norm + 0.4 * duration_rel."
      ]
    },
    "efficiency_score": {
      "description": "Combines sleep efficiency, sleep latency, and WASO.",
      "inputs": [
        "sleep_efficiency_pct",
        "sleep_latency_min",
        "waso_min"
      ],
      "algorithm": [
        "efficiency_component = map sleep_efficiency_pct: 95%+ => 100, 90% => 90, 85% => 80, 80% => 60, 70% => 40, <60% => 20 (with linear interpolation).",
        "latency_component = 100 if 5 <= latency <= 25; linearly down to 40 at 45 minutes, and 20 at 90 minutes; if latency < 5 minutes, penalize slightly to 70.",
        "waso_component = 100 if waso_min <= 20; 80 at 40 min; 60 at 60 min; 40 at 90 min; 20 beyond 120 min.",
        "efficiency_score = 0.5 * efficiency_component + 0.25 * latency_component + 0.25 * waso_component."
      ]
    },
    "structure_score": {
      "description": "Quality of sleep stage distribution.",
      "inputs": [
        "deep_pct",
        "rem_pct"
      ],
      "guidelines": {
        "deep_pct_ideal_min": 13,
        "deep_pct_ideal_max": 23,
        "rem_pct_ideal_min": 20,
        "rem_pct_ideal_max": 25
      },
      "algorithm": [
        "deep_score = 100 if deep_pct within [13,23]; linearly decreasing toward 40 at 5% or 30%, and 20 beyond those.",
        "rem_score = 100 if rem_pct within [20,25]; linearly decreasing toward 40 at 10% or 35%, and 20 beyond.",
        "structure_score = 0.5 * deep_score + 0.5 * rem_score."
      ]
    },
    "consistency_score": {
      "description": "How regular sleep timing and duration are over recent history.",
      "inputs": [
        "mid_sleep_time_local current night",
        "7-14 day history of mid_sleep_time_local",
        "total_sleep_min",
        "baseline_total_sleep_min"
      ],
      "algorithm": [
        "Compute sd_mid_sleep = standard deviation (hours) of mid_sleep_time_local over last 14 days.",
        "timing_score = 100 if sd_mid_sleep <= 0.75h; 80 at 1.0h; 60 at 1.5h; 40 at 2.0h; 20 beyond 2.5h.",
        "duration_consistency_score = 100 - 25 * |total_sleep_min - baseline_total_sleep_min| / 60, clamped to [40,100].",
        "consistency_score = 0.6 * timing_score + 0.4 * duration_consistency_score."
      ]
    },
    "recovery_score": {
      "description": "Optional score using vitals to gauge recovery and illness.",
      "inputs": [
        "resting_heart_rate vs baseline",
        "hrv vs baseline",
        "respiratory_rate vs baseline",
        "wrist_temperature vs baseline",
        "oxygen_saturation vs baseline"
      ],
      "algorithm": [
        "Compute z-scores for each vital metric relative to 28-day baseline.",
        "Resting HR: lower than baseline by up to 1σ is positive, higher is negative.",
        "HRV: higher than baseline by up to 1σ is positive, lower is negative.",
        "Respiratory rate and wrist temp: large positive deviations (e.g. z > 1.0) strongly penalize.",
        "SpO2: values below 94% or significantly below baseline penalize.",
        "Combine into recovery_score in [0,100], where ~70 is typical baseline, >85 indicates very good recovery, and <50 indicates possible strain/illness.",
        "If vitals are unavailable, mark recovery_score as null and exclude from final SleepScore weighting."
      ]
    }
  },
  "final_sleep_score": {
    "description": "Combine subscores into 0–100 Sleep Score with simple categories.",
    "weights": {
      "duration_score": 0.25,
      "efficiency_score": 0.20,
      "structure_score": 0.20,
      "consistency_score": 0.20,
      "recovery_score": 0.15
    },
    "fallback_weighting": "If recovery_score is null, renormalize remaining weights proportionally so they sum to 1.0.",
    "formula": [
      "SleepScore_raw = 0.25 * duration_score + 0.20 * efficiency_score + 0.20 * structure_score + 0.20 * consistency_score + 0.15 * recovery_score (if available).",
      "Clamp SleepScore_raw to [1, 99].",
      "SleepScore = round(SleepScore_raw).",
      "Optionally apply additional penalties or bonuses for extreme conditions (e.g., strong illness signals or severe sleep deprivation) in the range of +/- 5 points."
    ],
    "labels": {
      "0-49": "Low",
      "50-69": "Fair",
      "70-84": "Good",
      "85-100": "Excellent"
    }
  },
  "implementation_notes": {
    "language_and_platform": "Implement in Swift/iOS with HealthKit APIs. Expose a simple function like `func computeSleepScore(for sleepDay: Date, completion: (SleepNightSummary) -> Void)` where SleepNightSummary is a struct containing all nightly_metrics plus subscores and final SleepScore.",
    "timezones": "Always convert HealthKit sample timestamps to the correct local timezone using HKMetadataKeyTimeZone when present. Store canonical nightly records with both UTC timestamps and local-time references used for UI.",
    "idempotency": "Design nightly computation to be idempotent; if new samples arrive for the same night, recompute the summary and SleepScore.",
    "minimum_data_requirements": [
      "Require at least 3 hours of total_sleep_min to compute a full SleepScore.",
      "Require at least 5 historic nights to compute personalized baselines; before that, rely purely on guideline-based scoring and flag as 'baseline establishing'."
    ],
    "extensibility": "Keep scoring functions modular so weights and band thresholds can be tuned without schema changes."
  }
}
