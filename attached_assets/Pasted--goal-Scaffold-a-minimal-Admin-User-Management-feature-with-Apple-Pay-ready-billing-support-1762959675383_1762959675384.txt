{
  "goal": "Scaffold a minimal Admin > User Management feature with Apple Pay–ready billing support. Admins can list/search users, change role (free/premium/admin), toggle active/suspended, and view basic billing status. Include Stripe-based Apple Pay integration fields and endpoints.",
  "stack_assumptions": {
    "frontend": "React + Vite + TypeScript",
    "backend": "Node.js + Express",
    "db": "PostgreSQL + Drizzle ORM",
    "auth": "JWT or session-based (assume existing)",
    "payments": "Stripe (Apple Pay via Payment Request / iOS native)"
  },
  "env_vars_required": [
    "STRIPE_SECRET_KEY",
    "STRIPE_PUBLISHABLE_KEY",
    "BILLING_PROVIDER=stripe",
    "APP_BASE_URL",
    "APPLE_MERCHANT_ID",
    "APPLE_MERCHANT_DOMAIN",
    "APPLE_MERCHANT_COUNTRY_CODE",
    "DEFAULT_CURRENCY=USD"
  ],
  "acceptance_criteria": [
    "RBAC: Only admins can access /admin and /api/admin/*.",
    "Admin UI at /admin/users: search by email/name, filter by role/status, paginate.",
    "Inline actions: Change role (free/premium/admin), Toggle active/suspended.",
    "PATCH endpoint validates changes with zod and logs an audit record.",
    "Billing read-only panel in user drawer: plan, status, next/period end, last payment (if any).",
    "Stripe integration scaffolding: endpoints to create a PaymentIntent and Subscription (server), typed client helpers (no UI pay flow yet).",
    "Drizzle schema includes role/status enums, billing tables (customers, subscriptions, payments) with Stripe IDs and Apple Pay–useful meta (country code, last4, brand).",
    "Unit tests for RBAC middleware and PATCH users/:id happy-path + 403.",
    "No PAN or raw Apple Pay token stored; store only provider IDs and non-sensitive metadata."
  ],
  "db_schema_patches": {
    "file": "server/src/db/schema.ts",
    "content": "// Drizzle schema additions (PostgreSQL)\nimport { pgTable, serial, varchar, text, timestamp, pgEnum, integer, boolean, jsonb } from 'drizzle-orm/pg-core';\n\nexport const roleEnum = pgEnum('user_role', ['free','premium','admin']);\nexport const statusEnum = pgEnum('user_status', ['active','suspended']);\nexport const providerEnum = pgEnum('billing_provider', ['stripe']);\nexport const subStatusEnum = pgEnum('subscription_status', ['incomplete','incomplete_expired','trialing','active','past_due','canceled','unpaid']);\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  email: varchar('email', { length: 255 }).notNull().unique(),\n  name: varchar('name', { length: 255 }),\n  role: roleEnum('role').notNull().default('free'),\n  status: statusEnum('status').notNull().default('active'),\n  tosAcceptedAt: timestamp('tos_accepted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n});\n\nexport const auditLogs = pgTable('audit_logs', {\n  id: serial('id').primaryKey(),\n  adminId: integer('admin_id').notNull(),\n  action: varchar('action', { length: 128 }).notNull(),\n  targetUserId: integer('target_user_id'),\n  payload: jsonb('payload'),\n  createdAt: timestamp('created_at').defaultNow().notNull()\n});\n\n// Billing: minimal Stripe + Apple Pay–friendly fields (no sensitive card data)\nexport const billingCustomers = pgTable('billing_customers', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull().unique(),\n  provider: providerEnum('provider').notNull().default('stripe'),\n  providerCustomerId: varchar('provider_customer_id', { length: 255 }).notNull(), // Stripe customer id\n  countryCode: varchar('country_code', { length: 2 }), // for tax rules and Apple Pay country\n  defaultPmLast4: varchar('default_pm_last4', { length: 4 }),\n  defaultPmBrand: varchar('default_pm_brand', { length: 32 }),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n});\n\nexport const subscriptions = pgTable('subscriptions', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull(),\n  provider: providerEnum('provider').notNull().default('stripe'),\n  providerSubscriptionId: varchar('provider_subscription_id', { length: 255 }).notNull(), // Stripe sub id\n  priceId: varchar('price_id', { length: 255 }),\n  status: subStatusEnum('status').notNull(),\n  currentPeriodStart: timestamp('current_period_start'),\n  currentPeriodEnd: timestamp('current_period_end'),\n  cancelAt: timestamp('cancel_at'),\n  canceledAt: timestamp('canceled_at'),\n  trialEnd: timestamp('trial_end'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n});\n\nexport const payments = pgTable('payments', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull(),\n  provider: providerEnum('provider').notNull().default('stripe'),\n  providerPaymentId: varchar('provider_payment_id', { length: 255 }).notNull(), // Stripe pi_xxx or ch_xxx\n  amountCents: integer('amount_cents').notNull(),\n  currency: varchar('currency', { length: 10 }).notNull().default('USD'),\n  status: varchar('status', { length: 32 }).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull()\n});\n"
  },
  "server_routes": [
    {
      "file": "server/src/middleware/rbac.ts",
      "content": "import { Request, Response, NextFunction } from 'express';\nexport function requireAdmin(req: Request, res: Response, next: NextFunction) {\n  const user = (req as any).user; // assume auth middleware already set req.user\n  if (!user || user.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\n  return next();\n}\n"
    },
    {
      "file": "server/src/routes/adminUsers.ts",
      "content": "import { Router } from 'express';\nimport { z } from 'zod';\nimport { requireAdmin } from '../middleware/rbac';\nimport { db } from '../db/client';\nimport { users, auditLogs, roleEnum, statusEnum } from '../db/schema';\nimport { and, ilike, eq } from 'drizzle-orm';\n\nconst router = Router();\nrouter.use(requireAdmin);\n\nrouter.get('/', async (req, res) => {\n  const q = String(req.query.q || '').trim();\n  const role = String(req.query.role || '');\n  const status = String(req.query.status || '');\n  const page = Math.max(parseInt(String(req.query.page || '1')), 1);\n  const pageSize = Math.min(Math.max(parseInt(String(req.query.pageSize || '20')), 1), 100);\n\n  const where = [] as any[];\n  if (q) where.push(ilike(users.email, `%${q}%`));\n  if (role) where.push(eq(users.role, role as any));\n  if (status) where.push(eq(users.status, status as any));\n\n  const [rows, [{ count }]] = await Promise.all([\n    db.select().from(users).where(where.length ? and(...where) : undefined).limit(pageSize).offset((page-1)*pageSize),\n    db.execute(\"SELECT COUNT(*)::int as count FROM users\") as any\n  ]);\n  res.json({ data: rows, page, pageSize, total: count });\n});\n\nconst patchBody = z.object({\n  role: z.enum(['free','premium','admin']).optional(),\n  status: z.enum(['active','suspended']).optional()\n}).refine((d) => Object.keys(d).length > 0, { message: 'No changes' });\n\nrouter.patch('/:id', async (req, res) => {\n  const parse = patchBody.safeParse(req.body);\n  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });\n  const id = parseInt(req.params.id, 10);\n  if (Number.isNaN(id)) return res.status(400).json({ error: 'Invalid id' });\n\n  const [existing] = await db.select().from(users).where(eq(users.id, id));\n  if (!existing) return res.status(404).json({ error: 'User not found' });\n\n  const updates: any = {};\n  if (parse.data.role) updates.role = parse.data.role;\n  if (parse.data.status) updates.status = parse.data.status;\n\n  const [updated] = await db.update(users).set(updates).where(eq(users.id, id)).returning();\n\n  await db.insert(auditLogs).values({\n    adminId: (req as any).user.id,\n    action: 'admin.update_user',\n    targetUserId: id,\n    payload: updates\n  });\n  res.json({ data: updated });\n});\n\nexport default router;\n"
    },
    {
      "file": "server/src/routes/billing.ts",
      "content": "import { Router } from 'express';\nimport Stripe from 'stripe';\nimport { requireAdmin } from '../middleware/rbac';\nimport { db } from '../db/client';\nimport { billingCustomers, subscriptions, payments } from '../db/schema';\nimport { eq } from 'drizzle-orm';\n\nconst router = Router();\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' });\n\n// Admin: read billing snapshot for a user\nrouter.get('/admin/users/:userId', requireAdmin, async (req, res) => {\n  const userId = parseInt(req.params.userId, 10);\n  const [cust] = await db.select().from(billingCustomers).where(eq(billingCustomers.userId, userId));\n  const subs = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId));\n  const pays = await db.select().from(payments).where(eq(payments.userId, userId));\n  res.json({ customer: cust, subscriptions: subs, payments: pays });\n});\n\n// Public (authed user): create payment intent for one-off (Apple Pay via Stripe Payment Request)\nrouter.post('/create-payment-intent', async (req, res) => {\n  const { amountCents, currency = process.env.DEFAULT_CURRENCY || 'USD' } = req.body;\n  if (!amountCents || amountCents < 50) return res.status(400).json({ error: 'Invalid amount' });\n  const intent = await stripe.paymentIntents.create({ amount: amountCents, currency, automatic_payment_methods: { enabled: true } });\n  res.json({ clientSecret: intent.client_secret });\n});\n\n// Public (authed user): create subscription (expects priceId)\nrouter.post('/create-subscription', async (req, res) => {\n  const user = (req as any).user; // assume auth middleware present\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  const { priceId } = req.body;\n  if (!priceId) return res.status(400).json({ error: 'Missing priceId' });\n\n  // find/create Stripe customer\n  let [cust] = await db.select().from(billingCustomers).where(eq(billingCustomers.userId, user.id));\n  if (!cust) {\n    const sc = await stripe.customers.create({ email: user.email, name: user.name || undefined });\n    const result = await db.insert(billingCustomers).values({ userId: user.id, provider: 'stripe', providerCustomerId: sc.id }).returning();\n    cust = result[0];\n  }\n\n  const sub = await stripe.subscriptions.create({ customer: cust.providerCustomerId, items: [{ price: priceId }], payment_behavior: 'default_incomplete', expand: ['l]()
