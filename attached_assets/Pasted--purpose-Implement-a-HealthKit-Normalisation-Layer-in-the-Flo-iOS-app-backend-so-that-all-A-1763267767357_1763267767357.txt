{
  "purpose": "Implement a HealthKit Normalisation Layer in the Flo iOS app + backend so that all Apple Health data (especially steps) is converted into clean, per-day, per-user, timezone-correct aggregates before the readiness engine uses it.",
  "high_level_principles": {
    "1": "Normalise first, analyse later. The readiness engine must never operate on raw HealthKit samples.",
    "2": "Respect user-local time and day boundaries (timezone-aware, not UTC).",
    "3": "Handle multiple devices and sources without double-counting (Apple Watch vs iPhone vs other apps).",
    "4": "Prefer on-device aggregation, send small, clean daily summaries to backend.",
    "5": "Include provenance metadata (sources, time windows, normalisation version) for debugging and future upgrades."
  },
  "scope": {
    "platform": "iOS client (Swift/SwiftUI) with HealthKit + Flo backend (TypeScript/Node/Postgres)",
    "data_flow": "HealthKit raw samples → iOS normalisation pipeline → daily summary payload → backend DB → readiness engine",
    "metrics_in_scope_initially": [
      "steps",
      "active_energy_kcal",
      "sleep_hours",
      "resting_hr",
      "hrv_ms"
    ]
  },
  "normalised_data_contract": {
    "daily_payload_from_ios_to_backend": {
      "description": "One record per user per local calendar day per metric bundle.",
      "example_json": {
        "user_id": "uuid-or-app-user-id",
        "local_date": "YYYY-MM-DD (string, e.g. '2025-11-16')",
        "timezone": "IANA string, e.g. 'Australia/Perth'",
        "utc_day_start": "ISO timestamp for start of that local day in UTC",
        "utc_day_end": "ISO timestamp for end of that local day in UTC",
        "metrics": {
          "steps_normalized": 10432,
          "steps_raw_sum": 11750,
          "active_energy_kcal": 640,
          "sleep_hours": 7.8,
          "resting_hr_bpm": 58,
          "hrv_ms": 52
        },
        "sources": {
          "steps": {
            "primary_source": "apple_watch",
            "secondary_sources_used": ["iphone"],
            "ignored_sources": ["third_party_app_x"],
            "normalization_version": "steps_norm_v1"
          },
          "sleep": {
            "primary_source": "apple_watch",
            "normalization_version": "sleep_norm_v1"
          }
        }
      }
    }
  },
  "steps_normalisation_strategy": {
    "goal": "Produce a reliable daily step count that avoids double-counting across Apple Watch, iPhone, and other sources, aligned to the user's local day and timezone.",
    "healthkit_basics": {
      "type": "HKQuantityTypeIdentifierStepCount",
      "raw_sample_fields_used": [
        "quantity (count)",
        "startDate",
        "endDate",
        "sourceRevision (source bundle ID, app, device type, etc.)",
        "device (to detect Apple Watch vs iPhone)"
      ]
    },
    "source_priority_model": {
      "priority_order": [
        "apple_watch",
        "iphone",
        "other"
      ],
      "detection_rules": {
        "apple_watch": "sample.device?.model or name indicates Apple Watch",
        "iphone": "sample.device?.model or name indicates iPhone",
        "other": "anything else, including 3rd party apps that write steps"
      },
      "rationale": "Apple Watch is typically the most accurate step counter. iPhone is used as fallback when the watch is not worn or not present. Other apps are often derived/duplicated data and should be ignored by default unless whitelisted."
    },
    "per_day_normalisation_algorithm_v1": {
      "input": "All step samples for [utc_day_start, utc_day_end] covering the local day, queried in the user's local timezone.",
      "steps": [
        "1. Determine the user's local timezone from app settings or device.",
        "2. Compute local day boundaries using that timezone (local_start = start of day; local_end = next day's start).",
        "3. Query HealthKit for all StepCount samples where sample.startDate < local_end AND sample.endDate > local_start.",
        "4. For any sample that crosses midnight, split it into two (or more) samples so that each lies fully within a single local day segment. Split the step count proportionally by time.",
        "5. Partition samples by source category: apple_watch_samples, iphone_samples, other_samples.",
        "6. Check if there are any apple_watch_samples for that local day.",
        "7a. If apple_watch_samples exist: treat Apple Watch as primary sensor.",
        "    - Build a timeline of watch coverage using watch samples (union of [startDate, endDate] intervals).",
        "    - Sum all apple_watch_samples to get base_watch_steps.",
        "    - For iphone_samples, only add steps that occur during time intervals where there is NO overlapping Apple Watch coverage.",
        "    - Ignore other_samples by default (or include only when explicitly configured).",
        "    - Result: steps_normalized = base_watch_steps + iphone_steps_in_watch_gaps.",
        "7b. If NO apple_watch_samples exist for that day:",
        "    - Use iPhone as primary sensor: sum all iphone_samples.",
        "    - Optionally include other_samples if they are considered trusted and non-duplicated.",
        "    - Result: steps_normalized = sum(iphone_samples [+ optional_other_samples]).",
        "8. Compute steps_raw_sum as the sum of all samples from all sources before any deduplication (for debugging/QA).",
        "9. Apply basic outlier detection: if steps_normalized > 3x rolling 30-day median for this user, flag 'suspicious_steps' and include this flag in metadata. Do NOT auto-correct yet; just mark.",
        "10. Return normalized per-day step totals with metadata about which sources were used and what normalisation version was applied."
      ]
    }
  },
  "timezone_and_day_bucket_strategy": {
    "principles": [
      "All daily aggregates (steps, sleep, energy, HRV, etc.) are defined in terms of the user's local calendar day.",
      "Never bucket by raw UTC day for readiness-related metrics.",
      "Support users who travel across timezones by using the timezone that was active on the device when the day was recorded."
    ],
    "implementation_details": [
      "1. On-device, obtain TimeZone.current and the user's local calendar.",
      "2. For a given 'targetDate' (local date), compute localStart = calendar.startOfDay(for: targetDate) in that timezone, localEnd = localStart + 24h.",
      "3. Use these localStart/localEnd timestamps when querying HealthKit.",
      "4. If a sample spans multiple local days, split it into multiple samples, each truncated at local day boundaries and with value proportionally divided.",
      "5. When sending aggregated data to the backend, include:",
      "   - local_date: the user's local date string (YYYY-MM-DD).",
      "   - timezone: IANA timezone string, e.g. 'Australia/Perth'.",
      "   - utc_day_start and utc_day_end: the UTC equivalents of that local day range.",
      "6. In the backend, store both local_date (for UI and readiness logic) and utc_day_start/utc_day_end (for precise queries and audit)."
    ]
  },
  "backend_schema_additions": {
    "table_user_daily_metrics_extension": {
      "add_columns": {
        "timezone": "text (IANA timezone string, e.g. 'Australia/Perth')",
        "utc_day_start": "timestamptz – start of that local day in UTC",
        "utc_day_end": "timestamptz – end of that local day in UTC",
        "steps_normalized": "numeric",
        "steps_raw_sum": "numeric",
        "steps_sources_json": "jsonb – primary/secondary sources and flags like 'suspicious_steps'"
      }
    }
  },
  "other_metric_normalisation_notes": {
    "active_energy_kcal": [
      "Aggregate by summing all ActiveEnergyBurned samples within the local day.",
      "Double-counting is less of a concern than with steps, but ideally apply a similar source priority approach (Apple Watch > iPhone > other)."
    ],
    "sleep_hours": [
      "Use HKCategoryTypeIdentifierSleepAnalysis.",
      "Normalize by splitting samples across local day boundaries.",
      "Decide whether to assign sleep to 'bedtime day' (day you went to bed) or 'wake day' (day you woke up); for readiness, 'night before current day' is typically the sleep that ends in the morning of the current local_date.",
      "Implement a function to compute 'last night sleep hours for local_date', independently of where it straddles midnight."
    ]
  },
  "dev_tasks": [
    "1. In the iOS app, create a HealthKitNormalisationService that handles querying and normalising daily data (steps, sleep, energy, HRV, RHR) for a given local_date and timezone.",
    "2. Implement the steps_normalised algorithm described above (v1), including device/source prioritisation and overlap merging.",
    "3. Implement timezone-aware day bucketing and sample splitting across day boundaries.",
    "4. Implement a daily sync routine that computes the daily payload for the last N days (e.g., 7-30 days) and sends normalized daily summaries to the backend.",
    "5. On the backend, extend the user_daily_metrics table and ingestion endpoint to accept the normalized daily payload and store it as the single source of truth.",
    "6. Ensure the readiness engine only consumes normalized metrics from user_daily_metrics and never raw HealthKit samples.",
    "7. Add logging/metrics to detect suspicious outliers (e.g., steps_normalized vs steps_raw_sum, vs historical median) for QA.",
    "8. Document normalization_version (e.g., 'steps_norm_v1') so future algorithm changes can be versioned without breaking historical data."
  ]
}
