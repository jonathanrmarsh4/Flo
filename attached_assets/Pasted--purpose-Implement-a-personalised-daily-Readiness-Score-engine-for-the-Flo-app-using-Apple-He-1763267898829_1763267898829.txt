{
  "purpose": "Implement a personalised daily Readiness Score engine for the Flo app using Apple Health data plus user profile data. The engine should compute a 0–100 readiness score, sub-scores, and adapt over time to each user's natural baselines (sleep, HRV, resting HR, and activity).",
  "tech_stack_hint": {
    "language": "TypeScript",
    "runtime": "Node.js",
    "db": "PostgreSQL (via existing ORM in Flo, e.g. Drizzle)",
    "integration": "Flo backend receives HealthKit-aggregated data from the app or sync service; this engine runs server-side as a pure function plus scheduled baseline updater."
  },
  "high_level_requirements": {
    "readiness_score": {
      "range": "0–100 (integer or float)",
      "components": [
        "sleep_score (0–100)",
        "recovery_score (0–100) – HRV + resting HR",
        "load_score (0–100) – activity vs baseline",
        "trend_score (0–100) – short trend / smoothing"
      ],
      "weights": {
        "sleep_score_weight": 0.35,
        "recovery_score_weight": 0.35,
        "load_score_weight": 0.2,
        "trend_score_weight": 0.1
      },
      "buckets": [
        { "label": "recover", "min": 0, "max": 59 },
        { "label": "ok", "min": 60, "max": 79 },
        { "label": "ready", "min": 80, "max": 100 }
      ]
    },
    "personalisation": {
      "principle": "Score everything relative to the user's own rolling baselines, not population norms.",
      "baseline_window_days": 30,
      "minimum_days_for_confident_baseline": 14,
      "early_phase": "If <14 days of data for a metric, use shorter rolling windows and limit how extreme readiness can be (e.g. clamp between 50 and 90 and show 'calibrating' flag)."
    }
  },
  "inputs_and_models": {
    "inputs_per_day": {
      "user_id": "string/uuid",
      "date": "ISO date string",
      "metrics": {
        "sleep_hours": "number | null – total hours of sleep last night from HealthKit",
        "resting_hr": "number | null – beats per minute",
        "hrv_ms": "number | null – SDNN or RMSSD in ms",
        "active_energy_kcal": "number | null – daily active energy from HealthKit",
        "steps": "number | null – optional, may be used later",
        "respiratory_rate": "number | null – optional, future use",
        "other": "any additional HealthKit aggregates we might add later"
      },
      "historical_context": {
        "previous_days": "The engine should be able to query last N days of metrics for that user from the DB."
      }
    },
    "db_schema_suggestion": {
      "table_user_daily_metrics": {
        "name": "user_daily_metrics",
        "columns": {
          "id": "uuid primary key",
          "user_id": "uuid references users(id)",
          "date": "date",
          "sleep_hours": "numeric",
          "resting_hr": "numeric",
          "hrv_ms": "numeric",
          "active_energy_kcal": "numeric",
          "steps": "numeric",
          "source": "text – e.g. 'apple_health'",
          "created_at": "timestamptz",
          "updated_at": "timestamptz"
        },
        "constraints": [
          "unique (user_id, date)"
        ]
      },
      "table_user_metric_baselines": {
        "name": "user_metric_baselines",
        "purpose": "Store rolling baseline stats for each metric per user so we don't recompute from scratch every time.",
        "columns": {
          "id": "uuid primary key",
          "user_id": "uuid references users(id)",
          "metric_key": "text – e.g. 'sleep_hours', 'resting_hr', 'hrv_ms', 'active_energy_kcal'",
          "window_days": "integer – e.g. 30",
          "mean": "numeric",
          "std_dev": "numeric",
          "num_samples": "integer",
          "last_calculated_at": "timestamptz"
        },
        "index": [
          "index on (user_id, metric_key)"
        ]
      },
      "table_user_readiness": {
        "name": "user_daily_readiness",
        "purpose": "Persist daily readiness scores and components to show history and trends.",
        "columns": {
          "id": "uuid primary key",
          "user_id": "uuid references users(id)",
          "date": "date",
          "readiness_score": "numeric",
          "readiness_bucket": "text – 'recover' | 'ok' | 'ready'",
          "sleep_score": "numeric",
          "recovery_score": "numeric",
          "load_score": "numeric",
          "trend_score": "numeric",
          "is_calibrating": "boolean – true if baselines still immature",
          "notes_json": "jsonb – store extra explanation data if needed",
          "created_at": "timestamptz",
          "updated_at": "timestamptz"
        },
        "constraints": [
          "unique (user_id, date)"
        ]
      }
    },
    "core_function_signature": {
      "suggested": "async function computeDailyReadiness(userId: string, date: string): Promise<ReadinessResult>",
      "ReadinessResult_interface": {
        "userId": "string",
        "date": "string",
        "readinessScore": "number",
        "readinessBucket": "string",
        "sleepScore": "number | null",
        "recoveryScore": "number | null",
        "loadScore": "number | null",
        "trendScore": "number | null",
        "isCalibrating": "boolean",
        "explanations": {
          "summary": "string – 1-2 sentence summary",
          "sleep": "string",
          "recovery": "string",
          "load": "string",
          "trend": "string"
        }
      }
    }
  },
  "algorithm_details": {
    "sleep_score": {
      "description": "Compare last night's sleep hours to the user's rolling baseline sleep and penalise very short sleep.",
      "steps": [
        "Fetch sleep_hours for 'date' and the last N days (e.g. 30) for that user.",
        "Compute or load baseline_mean and baseline_std for 'sleep_hours' from user_metric_baselines.",
        "If not enough historical data (e.g. <7–10 days), use a shorter window and mark isCalibrating = true.",
        "Compute sleep_deviation = (today_sleep - baseline_mean) / baseline_mean.",
        "Clamp sleep_deviation to [-0.3, 0.3] to avoid extreme effects.",
        "Compute preliminary sleep_score = 70 + (sleep_deviation * 100).",
        "If today_sleep < 5 hours, cap sleep_score at max 40.",
        "Clamp final sleep_score to [0, 100]. If no sleep data, set sleep_score = null."
      ]
    },
    "recovery_score": {
      "description": "Use HRV (higher is better) and resting HR (lower is better) relative to the user's baselines.",
      "steps": [
        "Fetch today's hrv_ms and resting_hr for the date.",
        "Get baselines for hrv_ms and resting_hr (mean and std or mean only).",
        "For HRV: hrv_dev = (today_hrv - baseline_hrv) / baseline_hrv; clamp to [-0.3, 0.3].",
        "For resting HR: rhr_dev = (baseline_rhr - today_rhr) / baseline_rhr; clamp to [-0.3, 0.3].",
        "Convert to scores: hrv_score = clamp(70 + hrv_dev * 100, 0, 100); rhr_score = clamp(70 + rhr_dev * 100, 0, 100).",
        "Combine: recovery_score = 0.6 * hrv_score + 0.4 * rhr_score.",
        "If one metric missing, use the other alone. If both missing, set recovery_score = null."
      ]
    },
    "load_score": {
      "description": "How much activity did the user do vs their usual? Higher-than-normal load should reduce readiness.",
      "steps": [
        "Use yesterday's active_energy_kcal (or training load equivalent) as 'recent load'.",
        "Compute/load baseline_mean for active_energy_kcal over last 14–30 days.",
        "If baseline_mean is 0 or missing, set load_score = null and later reduce its weight in the final score.",
        "Compute load_dev = (yesterday_load - baseline_load) / baseline_load; clamp to [-0.5, 0.5].",
        "Compute load_score = 80 - (load_dev * 60).",
        "This means: significantly higher-than-normal load (positive dev) drives score down; much lower-than-normal load nudges it up.",
        "Clamp load_score to [0, 100]."
      ]
    },
    "trend_score": {
      "description": "Smooths out day-to-day noise by looking at recent history. MVP: average of last 3 days' readiness.",
      "mvp_steps": [
        "Fetch last 3 days of readiness scores (excluding today) from user_daily_readiness.",
        "If fewer than 2 past days exist, set trend_score = 70 and mark isCalibrating.",
        "Otherwise, trend_score = average(last_3_days_readiness), clamped to [0, 100]."
      ],
      "future_upgrade": "Use actual trends in HRV and sleep (slopes) to adjust upwards or downwards."
    },
    "final_readiness_calculation": {
      "steps": [
        "Start with weights: sleep 0.35, recovery 0.35, load 0.2, trend 0.1.",
        "If any component is null (missing), renormalise weights proportionally to only the available components.",
        "Compute readiness = weighted_sum(components).",
        "Clamp readiness to [0, 100].",
        "If baselines are still calibrating (insufficient data), clamp readiness to a narrower band, e.g. [50, 90].",
        "Assign bucket: readiness < 60 → 'recover'; 60–79 → 'ok'; 80+ → 'ready'."
      ]
    }
  },
  "baseline_updater": {
    "description": "Implement a scheduled job (e.g., daily) that recalculates or updates rolling baselines for each metric and user.",
    "behaviour": [
      "For each user_id and each metric_key (sleep_hours, resting_hr, hrv_ms, active_energy_kcal):",
      "Query last N days (e.g. 30) of user_daily_metrics where the metric is not null.",
      "Compute mean and standard deviation (std_dev).",
      "Store/update in user_metric_baselines with window_days, mean, std_dev, num_samples, last_calculated_at.",
      "Optionally skip metrics with very few samples (e.g. <5) and mark them as 'not ready'."
    ]
  },
  "edge_cases": {
    "no_data_for_today": "If there is absolutely no data for the target date, do not create a readiness record. Return an error or a special state.",
    "partial_data": "If only some metrics are present, compute the available component scores and re-weight the final score accordingly. Also include a flag in the result such as 'data_quality': 'partial'.",
    "new_user": "If the user has fewer than X days of history (e.g. 7–14), mark isCalibrating = true and restrict how extreme readiness can be.",
    "extreme_outliers": "If any metric lies > 3 standard deviations from baseline, optionally treat it as an outlier and cap its contribution."
  },
  "dev_tasks": [
    "Create/adjust DB migrations for user_daily_metrics, user_metric_baselines, and user_daily_readiness tables.",
    "Implement baseline updater job (daily cron or scheduled worker).",
    "Implement computeDailyReadiness(userId, date) as a pure, well-tested function using the above algorithm.",
    "Add unit tests for each component: sleep_score, recovery_score, load_score, trend_score, and final aggregation.",
    "Expose an API endpoint or service used by the app to fetch today's readiness and the past X days for charting.",
    "Ensure the function is deterministic and side-effect-free given the same inputs (for reproducibility and testing)."
  ]
}
